Grammar for the Cthulhu Assembler
Scot W. Stevenson <scot.stevenson@gmail.com>
First version: 07. Mai 2018
This version: 11. Mai 2018

We use EBNF as used by Go (see https://golang.org/ref/spec#Notation and
http://www.cs.sfu.ca/CourseCentral/383/tjd/ebnf_intro_in_go.html) for
our language description.

// A line can begin with one of four types:

statement = whitespace | comment | directive | label | instruction

comment = ";" { anything } "<EOL>"



directive = "." ( letter | dec_digit | "!" | "*" ) { letter | dec_digit | "!" | "*"  }
        for one of:

        ".*"
        ".a8"
        ".a16"
        ".axy16"
        ".advance" expr
        ".assert" "a8" | "a16" | "xy8" | "xy16" | "native" | "emulated"
        ".bank" expr
        ".byte" expr { "," expr } [ comment ] "<EOL>"
        ".emulate"
        ".end"
        ".equ" symbol expr
        ".include" string
        ".long" expr { "," expr }
        ".lsb" expr
        ".msb" 
        ".mpu" string, one of "6502" | "65c02" | "65816"
        ".native"
        ".notation" string, one of "san" | "wdc"
        ".origin" expr
        ".ram" expr [ { "," expr } | "-" expr ] 
        ".rom" expr [ { "," expr } | "-" expr ] 
        ".status"
        ".word" expr { "," expr } [ comment ] "<EOL>"
        ".xy16"
        ".xy8"
        

// Labels 

label = ( local_label | global_label | anon_label ) [ directive | instruction ] [ comment ]
local_label = "_" symbol
global_label = ":" symbol
anon_label = "@"

symbol = letter { letter | digit | sym_special }
sym_special = "!" | "?" | "_" | "&" | "'" | "#" | "." | "@" | "~" | "^" | "&" | "=" | "|"

// Instruction

instruction = instruction_wdc | instruction_san

instruction_wdc = ( opc_wdc_nopara [ comment ] ) |
                  ( opc_wdc [ operand ] [ comment ] ) 


opc_wdc_nopara = "brk" | ... | "nop" | ... | "tax" ... 

instruction_san = ( opc_san_0 [ comment ] ) |
                  ( opc_san_1 operand_san [ comment ] ) |
                  ( opc_san_2 operand_san "," operand_san [ comment ] )

operand_san = [ single_operator ] ( number | symbol | rpn ) | 
              ( number | symbol | rpn ) [ binary_operator ( number | symbol | rpn ) ]

operand_wdc = [ single_operator ] ["#"] ["("] ( number | symbol | rpn ) [")"] [",x" | ",y"]

single_operator = ".lsb" | ".msb" | ".bank" | ".not"
binary_operator = ".and" | ".or" | ".xor" | "+" | "-" | "/" | "*" | ".lshift" | 
        ".rshift" | "%"

// Reverse Polish Notation (RPN) 

rpn = "{" ( number | symbol )  { number | symbol | prn_operator } "}" 

rpn_operator = ".drop" | ".dup" | ".lsb" | ".msb" | ".bank" | "+" | "*" | "-" | "/" |
        ".and" | ".or" | ".xor" | ".not" | ".invert" | ".lshift" | ".rshift" | "%"


// Numbers

number = bin_number | dec_number | hex_number 

bin_number = '%' bin_digit { bin_digit | bin_special }
bin_special = ":" | "." 

dec_number = dec_digit { dec_digit }
dec_digit = "0" ... "9"

hex_number = '$' hex_digit { hex_digit | hex_special }
hex_special = ":" | "." 
hex_digit = dec_digit | "a" ... "f" | "A" ... "F"


// Basic types

string = "\"" { any_unicode } "\""
letter = "a" ... "z" | "A" ... "Z"


==== TYPES ====

In addition, numbers have types, which can be addresses, values, or offsets.

        addr = addr8 | addr16 | addr24
        value = value8 | value16 | value24
        offset = offset_small | offset_large

